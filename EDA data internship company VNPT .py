# -*- coding: utf-8 -*-
"""ki·∫øn t·∫≠p

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m9LbRfSUWgPzHbFa0hG_LmcZDApIAGXh
"""

!pip install -q seaborn
!pip install scikit-learn-extra

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from mpl_toolkits.mplot3d import Axes3D

df = pd.read_csv("/content/digital_wallet_transactions.csv")  # ƒê·ªïi ƒë∆∞·ªùng d·∫´n n·∫øu ch·∫°y local
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

print("üîπ K√≠ch th∆∞·ªõc d·ªØ li·ªáu g·ªëc:", df.shape)
print("üîπ C√°c c·ªôt trong d·ªØ li·ªáu:", list(df.columns))

df_cleaned = df.drop(columns=['idx', 'transaction_id', 'merchant_id'])

numeric_cols = ['product_amount', 'transaction_fee', 'cashback', 'loyalty_points']
Q1 = df_cleaned[numeric_cols].quantile(0.25)
Q3 = df_cleaned[numeric_cols].quantile(0.75)
IQR = Q3 - Q1
outlier_mask = ((df_cleaned[numeric_cols] < (Q1 - 1.5 * IQR)) |
                (df_cleaned[numeric_cols] > (Q3 + 1.5 * IQR))).any(axis=1)
df_filtered = df_cleaned[~outlier_mask]

print("üîπ S·ªë l∆∞·ª£ng giao d·ªãch b·ªã lo·∫°i b·ªè:", outlier_mask.sum())
print("üîπ K√≠ch th∆∞·ªõc sau khi lo·∫°i outlier:", df_filtered.shape)

snapshot_date = df_filtered['transaction_date'].max() + pd.Timedelta(days=1)
rfm = df_filtered.groupby('user_id').agg({
    'transaction_date': lambda x: (snapshot_date - x.max()).days,
    'user_id': 'count',
    'product_amount': 'sum'
}).rename(columns={
    'transaction_date': 'Recency',
    'user_id': 'Frequency',
    'product_amount': 'Monetary'
}).reset_index()

print("üîπ K√≠ch th∆∞·ªõc b·∫£ng RFM:", rfm.shape)
print(rfm.head())

scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm[['Recency', 'Frequency', 'Monetary']])

# 6. Ph√¢n c·ª•m b·∫±ng KMeans
print("\nüîπ √Åp d·ª•ng ph√¢n c·ª•m KMeans (k=4)...")
kmeans = KMeans(n_clusters=4, random_state=42)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)

print("üîπ G·∫Øn nh√£n c·ª•m th√†nh c√¥ng. Xem v√†i d√≤ng ƒë·∫ßu:")
print(rfm.head())

print("\nüîπ Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì ph√¢n c·ª•m 3D:")
def plot_3d_rfm(data, title):
    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(data['Recency'], data['Frequency'], data['Monetary'],
               c=data['Cluster'], cmap='viridis')
    ax.set_xlabel('Recency')
    ax.set_ylabel('Frequency')
    ax.set_zlabel('Monetary')
    ax.set_title(title)
    plt.show()

plot_3d_rfm(rfm, "Customer Segmentation using RFM and KMeans")

import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# T√≠nh SSE v·ªõi K t·ª´ 1 ƒë·∫øn 10
sse = {}
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(rfm_scaled)
    sse[k] = kmeans.inertia_

# V·∫Ω bi·ªÉu ƒë·ªì Elbow b·∫±ng matplotlib ƒë∆°n gi·∫£n
plt.figure(figsize=(8, 5))
plt.plot(list(sse.keys()), list(sse.values()), marker='o')
plt.title('Ph∆∞∆°ng ph√°p Elbow ')
plt.xlabel('S·ªë c·ª•m (k)')
plt.ylabel('SSE (T·ªïng b√¨nh ph∆∞∆°ng sai s·ªë trong c·ª•m)')
plt.xticks(range(1, 11))
plt.grid(True)
plt.show()

# 1. T√≥m t·∫Øt RFM trung b√¨nh theo c·ª•m
rfm_cluster_summary = rfm.groupby('Cluster').agg({
    'Recency': 'mean',
    'Frequency': 'mean',
    'Monetary': 'mean'
}).round(2)

print("üìä Trung b√¨nh RFM theo t·ª´ng c·ª•m:")
print(rfm_cluster_summary)

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

# D·ªØ li·ªáu ƒë√£ chu·∫©n h√≥a
rfm_scaled_df = pd.DataFrame(rfm_scaled, columns=['Recency', 'Frequency', 'Monetary'])

fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# V·∫Ω scatter v·ªõi nh√£n c·ª•m l√†m m√†u
scatter = ax.scatter(
    rfm_scaled_df['Recency'],
    rfm_scaled_df['Frequency'],
    rfm_scaled_df['Monetary'],
    c=rfm['Cluster'],
    cmap='viridis',
    s=50
)

# Thi·∫øt l·∫≠p nh√£n tr·ª•c
ax.set_xlabel('Recency')
ax.set_ylabel('Frequency')
ax.set_zlabel('Monetary')

# Th√™m ch√∫ th√≠ch
legend = ax.legend(*scatter.legend_elements(), title='Cluster')
ax.add_artist(legend)

plt.title('Clusters of Customers (3D)')
plt.show()

import pandas as pd

# ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV v√≠ d·ª•:
df = pd.read_csv('/content/digital_wallet_transactions.csv')  # ho·∫∑c ƒë∆∞·ªùng d·∫´n c·ªßa b·∫°n

# Chuy·ªÉn ƒë·ªïi ki·ªÉu ng√†y
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

snapshot_date = df['transaction_date'].max() + pd.Timedelta(days=1)

rfm = df.groupby('user_id').agg({
    'transaction_date': lambda x: (snapshot_date - x.max()).days,
    'user_id': 'count',
    'product_amount': 'sum'
}).rename(columns={
    'transaction_date': 'Recency',
    'user_id': 'Frequency',
    'product_amount': 'Monetary'
}).reset_index()

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

# Chu·∫©n h√≥a d·ªØ li·ªáu
scaler = StandardScaler()
rfm_normalized = scaler.fit_transform(rfm[['Recency', 'Frequency', 'Monetary']])

# KMeans ph√¢n c·ª•m
kmeans = KMeans(n_clusters=4, random_state=42)
rfm['Cluster'] = kmeans.fit_predict(rfm_normalized)

# V·∫Ω bi·ªÉu ƒë·ªì 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

scatter = ax.scatter(
    rfm_normalized[:, 0],
    rfm_normalized[:, 1],
    rfm_normalized[:, 2],
    c=rfm['Cluster'],
    cmap='viridis',
    s=50
)

ax.set_xlabel('Recency (normalized)')
ax.set_ylabel('Frequency (normalized)')
ax.set_zlabel('Monetary (normalized)')
plt.legend(*scatter.legend_elements(), title='Cluster')
plt.title("3D KMeans Clustering of RFM Scores")
plt.show()

import pandas as pd

# Gi·∫£ s·ª≠ b·∫°n ƒë√£ load file th√†nh c√¥ng v·ªõi:
# df = pd.read_csv('...')

# Chuy·ªÉn c·ªôt ng√†y v·ªÅ ƒë√∫ng ƒë·ªãnh d·∫°ng
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# T·∫°o snapshot date
snapshot_date = df['transaction_date'].max() + pd.Timedelta(days=1)

# T√≠nh b·∫£ng RFM
rfm = df.groupby('user_id').agg({
    'transaction_date': lambda x: (snapshot_date - x.max()).days,
    'user_id': 'count',
    'product_amount': 'sum'
}).rename(columns={
    'transaction_date': 'Recency',
    'user_id': 'Frequency',
    'product_amount': 'Monetary'
}).reset_index()

import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# ƒê·ªçc d·ªØ li·ªáu CSV t·ª´ file b·∫°n cung c·∫•p
df = pd.read_csv('digital_wallet_transactions.csv')  # ‚ö†Ô∏è ƒê·ªïi path n·∫øu c·∫ßn
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# T·∫°o b·∫£ng RFM
snapshot_date = df['transaction_date'].max() + pd.Timedelta(days=1)
customer = df.groupby('user_id').agg({
    'transaction_date': lambda x: (snapshot_date - x.max()).days,
    'user_id': 'count',
    'product_amount': 'sum'
}).rename(columns={
    'transaction_date': 'Recency',
    'user_id': 'Frequency',
    'product_amount': 'Monetary'
}).reset_index()

# Chu·∫©n h√≥a d·ªØ li·ªáu
scaler = StandardScaler()
rfm_normalized = scaler.fit_transform(customer[['Recency', 'Frequency', 'Monetary']])

# K-Medoids clustering
customer['Cluster'] = KMeans(n_clusters=5, random_state=0).fit_predict(rfm_normalized)

# Plotting in 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
colors = ['r', 'g', 'b', 'y', 'c']

for i in range(5):
    points = rfm_normalized[customer['Cluster'] == i]
    ax.scatter(points[:, 0], points[:, 1], points[:, 2],
               s=50, c=colors[i], label=f'Cluster {i}')

ax.set_title('3D K-Medoids Clustering of RFM Scores')
ax.set_xlabel('Recency (normalized)')
ax.set_ylabel('Frequency (normalized)')
ax.set_zlabel('Monetary (normalized)')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from mpl_toolkits.mplot3d import Axes3D

# Chu·∫©n h√≥a d·ªØ li·ªáu ƒë·∫ßu v√†o (n·∫øu c·∫ßn)
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
rfm_normalized = scaler.fit_transform(customer[['Recency', 'Frequency', 'Monetary']])

# √Ånh x·∫° l·∫°i DataFrame chu·∫©n h√≥a
customer_scaled = pd.DataFrame(rfm_normalized, columns=['Recency', 'Frequency', 'Monetary'])

# √Åp d·ª•ng KMeans++
kmeans_model = KMeans(n_clusters=5, init='k-means++', random_state=0)
customer_scaled['Cluster'] = kmeans_model.fit_predict(customer_scaled)

# V·∫Ω bi·ªÉu ƒë·ªì 3D
fig = plt.figure(figsize=(10, 9))
ax = fig.add_subplot(111, projection='3d')
scatter = ax.scatter(
    customer_scaled['Recency'],
    customer_scaled['Frequency'],
    customer_scaled['Monetary'],
    c=customer_scaled['Cluster'],
    cmap='viridis',
    s=40
)

ax.set_title('3D KMeans++ Clustering of RFM Scores')
ax.set_xlabel('Recency (normalized)')
ax.set_ylabel('Frequency (normalized)')
ax.set_zlabel('Monetary (normalized)')

# Th√™m ch√∫ th√≠ch
legend1 = ax.legend(*scatter.legend_elements(), title="Clusters")
ax.add_artist(legend1)

plt.show()

print(customer.describe())

#calculation of the RFM score
customer["RecencyScore"] = pd.qcut(customer["Recency"],5,labels=[5,4,3,2,1])

customer["FrequencyScore"] = pd.qcut(customer["Frequency"].rank(method="first"),5,labels=[1,2,3,4,5])

customer["MonetaryScore"] = pd.qcut(customer["Monetary"],5,labels=[1,2,3,4,5])

customer['RFM_SCORE']=customer['RecencyScore'].astype(str)+customer['FrequencyScore'].astype(str)+customer['MonetaryScore'].astype(str)
customer.head(5000)



# T·∫°o m√£ ph√¢n kh√∫c t·ª´ ƒëi·ªÉm RFM
customer['Segment'] = customer['RecencyScore'].astype(str) + \
                      customer['FrequencyScore'].astype(str) + \
                      customer['MonetaryScore'].astype(str)

# √Ånh x·∫° m√£ 3 ch·ªØ s·ªë sang t√™n g·ªçi ph√¢n kh√∫c
seg_map = {
    r'555': 'Champions',
    r'155': "Can't Lose Them",
    r'255': 'At Risk',
    r'111': 'Lost customers',
    r'211': 'About To Sleep',
    r'311': 'Hibernating',
    r'135': 'New Customers',
    r'355': 'Potential Loyalist',
    r'445': 'Loyal Customers',
    r'225': 'Needing Attention',
    # b·∫°n c√≥ th·ªÉ b·ªï sung th√™m t√πy dataset
}

# Thay m√£ ph√¢n kh√∫c b·∫±ng t√™n g·ªçi
customer['Segment'] = customer['Segment'].replace(seg_map, regex=True)

rfm_level_agg = customer.groupby('Segment').agg({
    'Recency': 'mean',
    'Frequency': 'mean',
    'Monetary': ['mean', 'count']
}).round(1)

print(rfm_level_agg)

"""Histogram"""

# V·∫Ω bi·ªÉu ƒë·ªì histogram cho gi√° tr·ªã Monetary
plt.figure(figsize=(10, 6))
sns.histplot(customer['Monetary'], bins=50, kde=True, color='skyblue', edgecolor='black')

# V·∫Ω bi·ªÉu ƒë·ªì histogram cho Frequency
plt.figure(figsize=(10, 6))
sns.histplot(customer['Frequency'], bins=30, kde=True, color='skyblue', edgecolor='black')

plt.figure(figsize=(10, 6))
sns.histplot(customer['Recency'], bins=30, kde=True, color='skyblue', edgecolor='black')

import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

# ƒê·ªçc d·ªØ li·ªáu
df = pd.read_csv('/content/digital_wallet_transactions.csv')

# Chuy·ªÉn transaction_date sang ƒë·ªãnh d·∫°ng datetime
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# T√¨m ng√†y giao d·ªãch m·ªõi nh·∫•t trong d·ªØ li·ªáu
latest_date = df['transaction_date'].max()

# T√≠nh Recency: s·ªë ng√†y t·ª´ giao d·ªãch g·∫ßn nh·∫•t c·ªßa m·ªói user ƒë·∫øn ng√†y cu·ªëi c√πng trong t·∫≠p d·ªØ li·ªáu
recency_df = df.groupby('user_id')['transaction_date'].max().reset_index()
recency_df['Recency'] = (latest_date - recency_df['transaction_date']).dt.days

# V·∫Ω bi·ªÉu ƒë·ªì boxplot
plt.figure(figsize=(8, 6))
plt.boxplot(recency_df['Recency'], vert=True, patch_artist=True, boxprops=dict(facecolor='cornflowerblue'))
plt.title('Recency')
plt.ylabel('Days')
plt.grid(axis='y')

# Th√™m ghi ch√∫ nh∆∞ trong lu·∫≠n vƒÉn
plt.figtext(0.5, -0.1, 'Figure 4.1: Boxplots of Recency', wrap=True, horizontalalignment='center', fontsize=12)

plt.show()

frequency_df['Frequency'].value_counts().sort_index()

plt.figure(figsize=(8, 6))
plt.boxplot(frequency_df['Frequency'], vert=True, patch_artist=True,
            boxprops=dict(facecolor='cornflowerblue'), showmeans=True)
plt.title('Frequency')
plt.ylabel('Number of Transactions')
plt.grid(axis='y')
plt.figtext(0.5, -0.1, 'Figure 4.2: Boxplots of Frequency', wrap=True, horizontalalignment='center', fontsize=12)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV (ƒë·∫£m b·∫£o b·∫°n ƒë√£ upload file v√†o Colab)
df = pd.read_csv('/content/digital_wallet_transactions.csv')

# T√≠nh t·ªïng chi ti√™u theo t·ª´ng kh√°ch h√†ng (Monetary)
monetary_df = df.groupby('user_id')['product_amount'].sum().reset_index()
monetary_df.rename(columns={'product_amount': 'Monetary'}, inplace=True)

# T√≠nh IQR
Q1 = monetary_df['Monetary'].quantile(0.25)
Q3 = monetary_df['Monetary'].quantile(0.75)
IQR = Q3 - Q1

# L·ªçc d·ªØ li·ªáu kh√¥ng c√≥ outliers
filtered_monetary = monetary_df[
    (monetary_df['Monetary'] >= Q1 - 1.5 * IQR) &
    (monetary_df['Monetary'] <= Q3 + 1.5 * IQR)
]

plt.figure(figsize=(8, 6))
plt.boxplot(filtered_monetary['Monetary'], vert=True, patch_artist=True,
            boxprops=dict(facecolor='cornflowerblue'))
plt.title('Monetary')
plt.ylabel('Total Amount Spent')
plt.grid(axis='y')

plt.show()

import pandas as pd
from datetime import datetime

# ƒê·ªçc d·ªØ li·ªáu
df = pd.read_csv('/content/digital_wallet_transactions.csv')
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# Ng√†y tham chi·∫øu ƒë·ªÉ t√≠nh Recency (l√† ng√†y m·ªõi nh·∫•t trong t·∫≠p d·ªØ li·ªáu)
ref_date = df['transaction_date'].max()

# Recency: s·ªë ng√†y k·ªÉ t·ª´ giao d·ªãch cu·ªëi ƒë·∫øn ref_date
recency_df = df.groupby('user_id')['transaction_date'].max().reset_index()
recency_df['Recency'] = (ref_date - recency_df['transaction_date']).dt.days

# Frequency: s·ªë l∆∞·ª£ng giao d·ªãch
frequency_df = df.groupby('user_id')['transaction_id'].nunique().reset_index()
frequency_df.rename(columns={'transaction_id': 'Frequency'}, inplace=True)

# Monetary: t·ªïng s·ªë ti·ªÅn ƒë√£ chi
monetary_df = df.groupby('user_id')['product_amount'].sum().reset_index()
monetary_df.rename(columns={'product_amount': 'Monetary'}, inplace=True)

# G·ªôp l·∫°i th√†nh b·∫£ng RFM
rfm = recency_df.merge(frequency_df, on='user_id').merge(monetary_df, on='user_id')

# T√≠nh ƒëi·ªÉm theo quintiles
rfm['R_Score'] = pd.qcut(rfm['Recency'], 5, labels=[5,4,3,2,1])  # Recency c√†ng th·∫•p c√†ng t·ªët
rfm['F_Score'] = pd.qcut(rfm['Frequency'].rank(method='first'), 5, labels=[1,2,3,4,5])
rfm['M_Score'] = pd.qcut(rfm['Monetary'].rank(method='first'), 5, labels=[1,2,3,4,5])

# T√≠nh RFM Score theo ƒë·ªãnh d·∫°ng R*100 + F*10 + M
rfm['RFM_Score'] = rfm['R_Score'].astype(int) * 100 + \
                   rfm['F_Score'].astype(int) * 10 + \
                   rfm['M_Score'].astype(int)

# ƒê·ªïi t√™n c·ªôt cho gi·ªëng b·∫£ng
rfm.rename(columns={'user_id': 'CustomerKey'}, inplace=True)

# Hi·ªÉn th·ªã v√†i d√≤ng ƒë·∫ßu
rfm[['CustomerKey', 'R_Score', 'F_Score', 'M_Score', 'RFM_Score']].head(5000)

plt.figure(figsize=(8, 5))
plt.boxplot(
    df['product_amount'],
    vert=True,
    patch_artist=True,
    flierprops=dict(marker='o', color='black', markersize=5),
    boxprops=dict(facecolor='lightblue'),
    medianprops=dict(color='black'),
    whiskerprops=dict(color='black'),
    capprops=dict(color='black')
)
plt.title('product_amount')
plt.ylabel('Amount')
plt.xticks([1], ['1'])
plt.ylim(0, 10000)  # Gi·ªõi h·∫°n tr·ª•c y nh∆∞ h√¨nh m·∫´u

plt.grid(axis='y')
plt.show()

import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt

# ƒê·ªçc d·ªØ li·ªáu
df = pd.read_csv('/content/digital_wallet_transactions.csv')
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# T√≠nh RFM
reference_date = df['transaction_date'].max()
rfm = df.groupby('user_id').agg({
    'transaction_date': lambda x: (reference_date - x.max()).days,
    'transaction_id': 'count',
    'product_amount': 'sum'
}).reset_index()

rfm.columns = ['CustomerKey', 'Recency', 'Frequency', 'Monetary']

# Chu·∫©n h√≥a d·ªØ li·ªáu RFM
scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm[['Recency', 'Frequency', 'Monetary']])

# Elbow method
wcss = []
K = range(2, 10)
for k in K:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(rfm_scaled)
    wcss.append(kmeans.inertia_)

# V·∫Ω bi·ªÉu ƒë·ªì Elbow
plt.figure(figsize=(10, 5))
plt.plot(K, wcss, 'bx-')
plt.xlabel('k')
plt.ylabel('Distortion')
plt.title('The Elbow Method Showing the Optimal k')
plt.show()

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# ƒê·ªçc d·ªØ li·ªáu
df = pd.read_csv("digital_wallet_transactions.csv")

# X·ª≠ l√Ω ng√†y
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# T√≠nh gi√° tr·ªã RFM
reference_date = df['transaction_date'].max()
rfm = df.groupby('user_id').agg({
    'transaction_date': lambda x: (reference_date - x.max()).days,
    'transaction_id': 'count',
    'product_amount': 'sum'
}).reset_index()

rfm.columns = ['CustomerKey', 'Recency', 'Frequency', 'Monetary']

# Chu·∫©n h√≥a
scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm[['Recency', 'Frequency', 'Monetary']])

# KMeans
kmeans = KMeans(n_clusters=5, random_state=42, n_init=10)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)

# V·∫Ω bi·ªÉu ƒë·ªì 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
scatter = ax.scatter(
    rfm['Recency'], rfm['Frequency'], rfm['Monetary'],
    c=rfm['Cluster'], cmap='viridis'
)
ax.set_xlabel('Recency')
ax.set_ylabel('Frequency')
ax.set_zlabel('Monetary')
ax.set_title('Customer Segmentation based on RFM')
legend = ax.legend(*scatter.legend_elements(), title="Clusters")
ax.add_artist(legend)
plt.show()

# B∆∞·ªõc 1: T·∫£i th∆∞ vi·ªán c·∫ßn thi·∫øt
import pandas as pd

# B∆∞·ªõc 2: T·∫£i file t·ª´ m√°y l√™n Colab (n·∫øu c·∫ßn)
from google.colab import files
uploaded = files.upload()

# B∆∞·ªõc 3: ƒê·ªçc file CSV (ƒë·∫£m b·∫£o t√™n file ƒë√∫ng)
df = pd.read_csv('digital_wallet_transactions.csv')

# B∆∞·ªõc 4: Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng ng√†y th√°ng
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# B∆∞·ªõc 5: T·ªïng s·ªë l∆∞·ª£ng kh√°ch h√†ng giao d·ªãch
total_unique_customers = df['user_id'].nunique()
print("T·ªïng s·ªë l∆∞·ª£ng kh√°ch h√†ng giao d·ªãch duy nh·∫•t:", total_unique_customers)

# B∆∞·ªõc 6: T·∫°o th√™m c·ªôt th√°ng (d·∫°ng Period: YYYY-MM)
df['month'] = df['transaction_date'].dt.to_period('M')

# B∆∞·ªõc 7: T√≠nh s·ªë kh√°ch h√†ng giao d·ªãch theo t·ª´ng th√°ng
monthly_customers = df.groupby('month')['user_id'].nunique().reset_index()
monthly_customers.columns = ['Month', 'Unique_Customers']
print("\nS·ªë l∆∞·ª£ng kh√°ch h√†ng giao d·ªãch theo t·ª´ng th√°ng:")
print(monthly_customers)

# ƒê·∫øm s·ªë l∆∞·ª£ng giao d·ªãch theo t·ª´ng product category
top_categories = df['product_category'].value_counts().head(10).reset_index()
top_categories.columns = ['Product Category', 'Number of Transactions']

# In b·∫£ng top 10
print("Top 10 danh m·ª•c s·∫£n ph·∫©m c√≥ nhi·ªÅu giao d·ªãch nh·∫•t:")
print(top_categories)

# (Tu·ª≥ ch·ªçn) V·∫Ω bi·ªÉu ƒë·ªì tr·ª±c quan
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.barh(top_categories['Product Category'], top_categories['Number of Transactions'], color='skyblue')
plt.gca().invert_yaxis()  # Danh m·ª•c nhi·ªÅu nh·∫•t n·∫±m tr√™n c√πng
plt.title('Top 10 Product Categories by Number of Transactions')
plt.xlabel('Number of Transactions')
plt.tight_layout()
plt.show()

# ƒê·∫øm s·ªë l∆∞·ª£ng giao d·ªãch theo merchant
top_merchants = df['merchant_name'].value_counts().head(10).reset_index()
top_merchants.columns = ['Merchant Name', 'Number of Transactions']

# In ra b·∫£ng top 10
print("Top 10 merchant c√≥ s·ªë l∆∞·ª£ng giao d·ªãch nhi·ªÅu nh·∫•t:")
print(top_merchants)

# (Tu·ª≥ ch·ªçn) V·∫Ω bi·ªÉu ƒë·ªì
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.barh(top_merchants['Merchant Name'], top_merchants['Number of Transactions'], color='lightgreen')
plt.gca().invert_yaxis()
plt.title('Top 10 Merchants by Number of Transactions')
plt.xlabel('Number of Transactions')
plt.tight_layout()
plt.show()

# B∆∞·ªõc 1: Chuy·ªÉn ƒë·ªïi c·ªôt ng√†y giao d·ªãch sang ƒë·ªãnh d·∫°ng datetime (n·∫øu ch∆∞a)
df['transaction_date'] = pd.to_datetime(df['transaction_date'])

# B∆∞·ªõc 2: T·∫°o c·ªôt th√°ng
df['month'] = df['transaction_date'].dt.to_period('M')

# B∆∞·ªõc 3: T√≠nh t·ªïng s·ªë ti·ªÅn cashback theo t·ª´ng th√°ng
monthly_cashback = df.groupby('month')['cashback'].sum().reset_index()
monthly_cashback.columns = ['Month', 'Total Cashback']

# B∆∞·ªõc 4: Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
print("T·ªïng s·ªë ti·ªÅn cashback theo t·ª´ng th√°ng:")
print(monthly_cashback)

# (Tu·ª≥ ch·ªçn) V·∫Ω bi·ªÉu ƒë·ªì
import matplotlib.pyplot as plt

monthly_cashback['Month'] = monthly_cashback['Month'].astype(str)
plt.figure(figsize=(12, 6))
plt.plot(monthly_cashback['Month'], monthly_cashback['Total Cashback'], marker='o', color='orange')
plt.title('T·ªïng s·ªë ti·ªÅn Cashback theo t·ª´ng th√°ng')
plt.xlabel('Th√°ng')
plt.ylabel('T·ªïng ti·ªÅn Cashback')
plt.grid(True)
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# ƒê·ªçc d·ªØ li·ªáu n·∫øu c·∫ßn (n·∫øu ƒë√£ c√≥ s·∫µn df th√¨ b·ªè qua d√≤ng n√†y)
# df = pd.read_csv('digital_wallet_transactions.csv')

# ƒê·∫øm s·ªë l∆∞·ª£ng giao d·ªãch theo ƒë·ªãa ƒëi·ªÉm
location_counts = df['location'].value_counts()

# ƒê·ªïi t√™n ƒë·ªãa ƒëi·ªÉm sang ti·∫øng Vi·ªát
location_labels = {
    'Urban': 'Th√†nh th·ªã',
    'Suburban': 'Ngo·∫°i √¥',
    'Rural': 'N√¥ng th√¥n'
}
translated_labels = [location_labels.get(loc, loc) for loc in location_counts.index]

# V·∫Ω bi·ªÉu ƒë·ªì h√¨nh tr√≤n
plt.figure(figsize=(8, 6))
colors = ['darkblue', 'firebrick', 'mediumturquoise']
plt.pie(location_counts, labels=translated_labels, autopct='%1.2f%%', colors=colors, startangle=90)
plt.title('T·ªïng s·ªë giao d·ªãch theo khu v·ª±c', fontsize=14, color='lightblue')
plt.legend(title='Khu v·ª±c', labels=translated_labels, loc='center left', bbox_to_anchor=(1, 0.5))
plt.axis('equal')  # Gi·ªØ bi·ªÉu ƒë·ªì h√¨nh tr√≤n tr√≤n ƒë·ªÅu

# N·ªÅn t·ªëi nh∆∞ trong v√≠ d·ª•
plt.style.use('dark_background')

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# ƒê·ªçc d·ªØ li·ªáu n·∫øu c·∫ßn
# df = pd.read_csv('digital_wallet_transactions.csv')

# T√≠nh t·ªïng chi ti√™u theo khu v·ª±c
total_spending_by_location = df.groupby('location')['product_amount'].sum()

# ƒê·ªïi nh√£n sang ti·∫øng Vi·ªát
location_labels = {
    'Urban': 'Th√†nh th·ªã',
    'Suburban': 'Ngo·∫°i √¥',
    'Rural': 'N√¥ng th√¥n'
}
translated_labels = [location_labels.get(loc, loc) for loc in total_spending_by_location.index]

# V·∫Ω bi·ªÉu ƒë·ªì h√¨nh tr√≤n
plt.figure(figsize=(8, 6))
colors = ['darkblue', 'firebrick', 'mediumturquoise']
plt.pie(total_spending_by_location, labels=translated_labels, autopct='%1.1f%%', colors=colors, startangle=90)
plt.title('T·ªïng chi ti√™u theo khu v·ª±c', fontsize=14, color='lightblue')
plt.legend(title='Khu v·ª±c', labels=translated_labels, loc='center left', bbox_to_anchor=(1, 0.5))
plt.axis('equal')  # Gi·ªØ h√¨nh tr√≤n ƒë·ªÅu

# N·ªÅn t·ªëi gi·ªëng h√¨nh m·∫´u
plt.style.use('dark_background')

plt.tight_layout()
plt.show()